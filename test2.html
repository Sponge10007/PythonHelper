<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>题目解析与解答</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 2px solid #3498db;
        }
        .question {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            page-break-inside: avoid;
        }
        .question-title {
            color: #2c3e50;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        .options {
            margin: 15px 0;
        }
        .option {
            margin-bottom: 8px;
            padding-left: 20px;
            position: relative;
        }
        .option::before {
            content: attr(data-label);
            font-weight: bold;
            position: absolute;
            left: 0;
        }
        .answer {
            background-color: #e8f4fc;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }
        .answer-title {
            font-weight: bold;
            color: #2980b9;
            margin-bottom: 8px;
        }
        .correct {
            color: #27ae60;
            font-weight: bold;
        }
        .incorrect {
            color: #e74c3c;
            font-weight: bold;
        }
        .score {
            float: right;
            background-color: #3498db;
            color: white;
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 14px;
        }
        @media print {
            body {
                background-color: white;
            }
            .question {
                box-shadow: none;
                border: 1px solid #ddd;
            }
        }
    </style>
</head>
<body>
    <h1>题目解析与解答</h1>

    <div class="question">
        <h2 class="question-title">问题 1: 球与盒子概率问题 <span class="score">分数: 3</span></h2>
        <p>We have m balls and m boxes. Each ball is assigned to one of the m boxes independently and uniformly at random (i.e., equally likely to each box). Suppose that m is sufficiently large, and e is the natural number, which of the following is FALSE?</p>
        <div class="options">
            <div class="option" data-label="A. ">The expected number of balls in a box is 1.</div>
            <div class="option" data-label="B. ">The expected number of empty boxes is m/e.</div>
            <div class="option" data-label="C. ">Suppose that one box can only contain one ball, and it will reject other balls if it already contains one. Then, the expected number of rejected balls is m/e.</div>
            <div class="option" data-label="D. ">Suppose a box can accommodate two balls, and will reject any additional balls. The expected number of boxes containing exactly two balls is m/e.</div>
        </div>
        <div class="answer">
            <div class="answer-title">解析与答案：</div>
            <p>选项D是FALSE。因为每个盒子恰好有两个球的期望数量是m/(2e)，而不是m/e。</p>
            <p>正确答案: <span class="correct">D</span></p>
            <p>评测结果: <span class="incorrect">答案错误</span></p>
        </div>
    </div>

    <div class="question">
        <h2 class="question-title">问题 2: 递归复杂度分析 <span class="score">分数: 3</span></h2>
        <p>Which of the asymptotic upper bound for the following recursive T(n) is correct?</p>
        <div class="options">
            <div class="option" data-label="A. ">T(n)=2T(n/2)+nlog<sub>2</sub>n. Then T(n)=O(nlog<sub>2</sub>n).</div>
            <div class="option" data-label="B. ">T(n)=T(n<sup>1/3</sup>)+T(n<sup>2/3</sup>)+logn. Then T(n)=O(lognloglogn)</div>
            <div class="option" data-label="C. ">T(n)=3T(n/2)+n. Then T(n)=O(n).</div>
            <div class="option" data-label="D. ">T(n)=2T(√n)+logn. Then T(n)=O(logn).</div>
        </div>
        <div class="answer">
            <div class="answer-title">解析与答案：</div>
            <p>选项A正确，根据主定理Case 2，T(n)=Θ(nlog n)。选项B也正确，递归树深度O(log log n)，每层工作O(log n)，因此T(n)=O(log n log log n)。但问题要求选择一个正确选项，因此答案是A。</p>
            <p>正确答案: <span class="correct">A</span></p>
            <p>评测结果: <span class="correct">答案正确</span></p>
        </div>
    </div>

    <div class="question">
        <h2 class="question-title">问题 3: 两个有序数组的第k小元素 <span class="score">分数: 3</span></h2>
        <p>Consider two disjoint sorted arrays A[1…m] and B[1…n], we would like to compute the k-th smallest element in the union of the two arrays, where k≤min{m,n}. Please choose the smallest possible running time among the following options.</p>
        <div class="options">
            <div class="option" data-label="A. ">O(logk)</div>
            <div class="option" data-label="B. ">O(logm)</div>
            <div class="option" data-label="C. ">O(logn)</div>
            <div class="option" data-label="D. ">O(logm+logn)</div>
        </div>
        <div class="answer">
            <div class="answer-title">解析与答案：</div>
            <p>最小可能运行时间是O(log k)，因为可以在两个数组的前k个元素上进行二分查找。</p>
            <p>正确答案: <span class="correct">A</span></p>
            <p>评测结果: <span class="correct">答案正确</span></p>
        </div>
    </div>

    <div class="question">
        <h2 class="question-title">问题 4: 动态表的摊还成本分析 <span class="score">分数: 3</span></h2>
        <p>In this problem, we would like to find the amortized cost of insertion in a dynamic table T. Initially the size of the table T is 1. The cost of insertion is 1 if the table is not full. When an item is inserted into a full table, the table T is expanded as a new table of size 3 times larger. Then, we copy all the elements of the old table into this new table, and insert the item in the new table.</p>
        <p>Let num(T) be the number of elements in the table T, and size(T) be the total number of slots of the table. Clearly, if the table T is full, the cost of one insertion is num(T)+1.</p>
        <p>Let D<sub>i</sub> denote the table after applying the ith operation on D<sub>i-1</sub>.</p>
        <p>Which of the following potential function Φ(D<sub>i</sub>) can help us achieve O(1) amortized cost per insertion?</p>
        <div class="options">
            <div class="option" data-label="A. ">Φ(D<sub>i</sub>)=num(T)−size(T)/3</div>
            <div class="option" data-label="B. ">Φ(D<sub>i</sub>)=2/3 (num(T)−size(T)/3)</div>
            <div class="option" data-label="C. ">Φ(D<sub>i</sub>)=2/3 (num(T)+size(T)/3)</div>
            <div class="option" data-label="D. ">Φ(D<sub>i</sub>)=num(T)+size(T)/3</div>
        </div>
        <div class="answer">
            <div class="answer-title">解析与答案：</div>
            <p>选项B可以实现O(1)摊还成本。势函数Φ = (3/2)(num(T) - size(T)/3)可得到摊还成本常数，但选项B中的2/3接近所需系数。</p>
            <p>正确答案: <span class="correct">B</span></p>
            <p>评测结果: <span class="correct">答案正确</span></p>
        </div>
    </div>

    <div class="question">
        <h2 class="question-title">问题 5: 左偏堆合并 <span class="score">分数: 3</span></h2>
        <p>Merge the two leftist heaps in the following figure. Which one of the following statements is FALSE?</p>
        <div class="options">
            <div class="option" data-label="A. ">4 and 3 are siblings</div>
            <div class="option" data-label="B. ">along the left path from the root, we have 1, 2, 4, and 8</div>
            <div class="option" data-label="C. ">6 is the right child of 5</div>
            <div class="option" data-label="D. ">2 and 4 have the same NPL</div>
        </div>
        <div class="answer">
            <div class="answer-title">解析与答案：</div>
            <p>选项D是FALSE。因为合并左倾堆后，节点2和4的NPL（Null Path Length）可能不同。例如，如果4是叶子节点，NPL=0，而2有右孩子，NPL≥1，因此NPL不同。</p>
            <p>正确答案: <span class="correct">D</span></p>
            <p>评测结果: <span class="incorrect">答案错误</span></p>
        </div>
    </div>

    <div class="question">
        <h2 class="question-title">问题 6: 自调整数据结构 <span class="score">分数: 3</span></h2>
        <p>In typical applications of data structures, it is not a single operation that is performed, but rather a sequence of operations, and the relevant complexity measure is not the time taken by one operation but the total time of a sequence. Hence instead of imposing any explicit structural constraint, we allow the data structure to be in an arbitrary state, and we design the access and update algorithms to adjust the structure in a simple, uniform way, so that the efficiency of future operations is improved. We call such a data structure self-adjusting. For example skew heaps and splay trees are such kind of structures.</p>
        <p>Which one of the following statements is FALSE about self-adjusting data structures?</p>
        <div class="options">
            <div class="option" data-label="A. ">They need less space, since no balance information is kept.</div>
            <div class="option" data-label="B. ">Their access and update algorithms are easy to understand and to implement.</div>
            <div class="option" data-label="C. ">In an amortized sense, ignoring constant factors, they can be at least as efficient as balanced structures.</div>
            <div class="option" data-label="D. ">Less local adjustments take place than in the corresponding balanced structures, especially during accesses.</div>
        </div>
        <div class="answer">
            <div class="answer-title">解析与答案：</div>
            <p>选项D是FALSE。因为自调整数据结构（如伸展树）在访问时可能进行多次局部调整，而平衡结构在访问时调整较少。</p>
            <p>正确答案: <span class="correct">D</span></p>
            <p>评测结果: <span class="correct">答案正确</span></p>
        </div>
    </div>

    <div class="question">
        <h2 class="question-title">问题 7: 并行合并算法分析 <span class="score">分数: 3</span></h2>
        <p>The Merging problem is to merge two non-decreasing arrays A(1), A(2), ..., A(n) and B(1), B(2), ..., B(n) into another non-decreasing array C(1), C(2), ..., C(2n). To solve it in parallel, we turn it into a Ranking problem. That is, to compute RANK(A(i),B) and RANK(B(i),A) for every 1≤i≤n, where RANK(e,S) is the position of e in S. The following psuedo-code is for solving the Ranking problem parallely.</p>
        <pre>for Pi, 1<=i<=n pardo
    RANK(A(i),B) := BS(A(i),B)
    RANK(B(i),A) := BS(B(i),A)</pre>
        <p>where BS(e,S) is to find the position of e in S by binary search.</p>
        <p>Which of the following gives the time and work load of the algorithm?</p>
        <div class="options">
            <div class="option" data-label="A. ">T(n)=O(logn), W(n)=O(nlogn)</div>
            <div class="option" data-label="B. ">T(n)=W(n)=O(nlogn)</div>
            <div class="option" data-label="C. ">T(n)=W(n)=O(n)</div>
            <div class="option" data-label="D. ">T(n)=O(logn), W(n)=O(n)</div>
        </div>
        <div class="answer">
            <div class="answer-title">解析与答案：</div>
            <p>二进制搜索每个需要O(log n)时间，有2n个任务，因此工作量W(n)=O(n log n)。并行执行时，如果有n个处理器，时间T(n)=O(log n)。</p>
            <p>正确答案: <span class="correct">A</span></p>
            <p>评测结果: <span class="correct">答案正确</span></p>
        </div>
    </div>
</body>
</html>