<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>题目解析报告</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .problem {
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 20px;
            margin-bottom: 20px;
        }
        .problem:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        h1 {
            text-align: center;
            color: #0056b3;
            margin-bottom: 30px;
        }
        h2 {
            color: #0056b3;
            border-bottom: 2px solid #0056b3;
            padding-bottom: 5px;
        }
        h3 {
            color: #343a40;
        }
        .meta-info p {
            margin: 5px 0;
            font-size: 1.1em;
        }
        .answer-correct {
            color: #28a745;
            font-weight: bold;
        }
        .answer-incorrect {
            color: #dc3545;
            font-weight: bold;
        }
        .judge-correct {
            color: #28a745;
            font-weight: bold;
        }
        .judge-incorrect {
            color: #dc3545;
            font-weight: bold;
        }
        b {
            color: #495057;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>判断题详细解析</h1>

        <div class="problem">
            <h2>题目 1-1</h2>
            <div class="meta-info">
                <p><b>题目:</b> 第 $n$ 个斐波那契数可以通过计算矩阵 $x^n$ 的分治方法来计算，其中矩阵 $x$ 为 $\left( \begin{smallmatrix} 0 & 1 \\ 1 & 1 \end{smallmatrix} \right)$。那么，第 $n^2$ 个斐波那契数 $F_{n^2}$ 可以在 $O(\log n)$ 的时间内计算出来。</p>
                <p><b>您的答案:</b> <span class="answer-incorrect">错误 (FALSE)</span></p>
                <p><b>评判结果:</b> <span class="judge-incorrect">错误 (WRONG_ANSWER)</span></p>
                <p><b>正确答案:</b> <span class="answer-correct">正确 (TRUE)</span></p>
            </div>
            <h3>解析:</h3>
            <p>计算第 $k$ 个斐波那契数 $F_k$ 使用矩阵快速幂的方法，其核心是计算 $x^k$。这个算法的时间复杂度是 $O(\log k)$，因为它利用了分治的思想（例如，$x^k = x^{k/2} \cdot x^{k/2}$）。</p>
            <p>题目要求计算第 $n^2$ 个斐波那契数，也就是要计算矩阵的 $n^2$ 次方。将 $k = n^2$ 代入时间复杂度 $O(\log k)$ 中，我们得到：
            $$O(\log(n^2))$$
            根据对数运算法则 $\log(a^b) = b \log a$，上式可以化简为：
            $$O(2 \log n)$$
            在 Big O 表示法中，常数因子（这里的 2）可以忽略，所以最终的时间复杂度是：
            $$O(\log n)$$
            因此，该陈述是<b>正确</b>的。</p>
        </div>

        <div class="problem">
            <h2>题目 1-2</h2>
            <div class="meta-info">
                <p><b>题目:</b> 如果我们为一个包含 $n$ 个元素的集合构建一个跳表（skip list），那么在最坏情况下，我们可以在 $O(\log n)$ 的时间内搜索或删除任何元素。</p>
                <p><b>您的答案:</b> <span class="answer-incorrect">正确 (TRUE)</span></p>
                <p><b>评判结果:</b> <span class="judge-incorrect">错误 (WRONG_ANSWER)</span></p>
                <p><b>正确答案:</b> <span class="answer-correct">错误 (FALSE)</span></p>
            </div>
            <h3>解析:</h3>
            <p>跳表是一种概率性数据结构，它为搜索、插入和删除操作提供<b>平均时间复杂度</b>为 $O(\log n)$ 的性能。这种高效性是通过随机化建立的多层链表结构实现的。</p>
            <p>然而，题目问的是<b>最坏情况</b>下的时间复杂度。跳表的最坏情况发生在随机化过程产生了一个极不平衡的结构时。理论上，有可能所有元素都只在最底层（第一层）的链表中，而上面没有任何“快速通道”。在这种情况下，跳表退化成一个普通的链表。在普通链表中搜索或删除一个元素需要遍历所有节点，因此最坏情况下的时间复杂度是 <b>$O(n)$</b>，而不是 $O(\log n)$。</p>
            <p>因此，该陈述是<b>错误</b>的。</p>
        </div>

        <div class="problem">
            <h2>题目 1-3</h2>
            <div class="meta-info">
                <p><b>题目:</b> 如果一个操作的期望时间复杂度是 $O(1)$，那么它的摊还时间复杂度也是 $O(1)$。</p>
                <p><b>您的答案:</b> <span class="answer-correct">错误 (FALSE)</span></p>
                <p><b>评判结果:</b> <span class="judge-correct">正确 (ACCEPTED)</span></p>
                <p><b>正确答案:</b> <span class="answer-correct">错误 (FALSE)</span></p>
            </div>
            <h3>解析:</h3>
            <p><b>期望时间复杂度 (Expected Time)</b> 和 <b>摊还时间复杂度 (Amortized Time)</b> 是两种不同的分析方法。</p>
            <ul>
                <li><b>期望时间</b>是基于概率的分析。它考虑了算法中随机选择的平均效果（例如，哈希表中的哈希函数或快速排序中的随机主元）。它分析的是对于一个随机输入或随机算法，单次操作的平均时间。</li>
                <li><b>摊还时间</b>是针对一个操作序列的分析。它保证在一个操作序列中，每个操作的平均开销是一个定值，即使序列中某个操作的实际开销非常大。它提供的是对整个序列的<b>最坏情况</b>下的平均性能保证，不涉及概率。</li>
            </ul>
            <p>一个操作可以有很好的期望时间，但摊还时间很差，反之亦然。这两个概念并不等同，也不能相互推导。因此，该陈述是<b>错误</b>的。</p>
        </div>

        <div class="problem">
            <h2>题目 1-4</h2>
            <div class="meta-info">
                <p><b>题目:</b> 在一个斜堆（skew heap）中，沿着右路径的轻节点（light nodes）的数量是 $O(\log N)$。</p>
                <p><b>您的答案:</b> <span class="answer-incorrect">错误 (FALSE)</span></p>
                <p><b>评判结果:</b> <span class="judge-incorrect">错误 (WRONG_ANSWER)</span></p>
                <p><b>正确答案:</b> <span class="answer-correct">正确 (TRUE)</span></p>
            </div>
            <h3>解析:</h3>
            <p>这个性质是左式堆（leftist heap）和斜堆（skew heap）摊还分析的基础。在摊还分析中，节点根据其子树的大小被分为“重节点”（heavy node）和“轻节点”（light node）。一个关键的引理是：<b>从根节点到任何节点的路径上，轻节点的数量最多为 $O(\log N)$</b>。</p>
            <p>斜堆是一种自适应的堆，它通过在每次合并操作后无条件地交换根的左右子节点来维护平衡。虽然单次操作可能会导致右路径变长，但摊还分析证明了一系列操作的总体效率。该分析正是依赖于任意路径上轻节点数量为对数级别的这个属性。因为右路径也是从根开始的一条路径，所以这个性质也适用于它。</p>
            <p>因此，该陈述是<b>正确</b>的。</p>
        </div>

        <div class="problem">
            <h2>题目 1-5</h2>
            <div class="meta-info">
                <p><b>题目:</b> 调试并行程序比调试普通的串行程序更简单。</p>
                <p><b>您的答案:</b> <span class="answer-correct">错误 (FALSE)</span></p>
                <p><b>评判结果:</b> <span class="judge-correct">正确 (ACCEPTED)</span></p>
                <p><b>正确答案:</b> <span class="answer-correct">错误 (FALSE)</span></p>
            </div>
            <h3>解析:</h3>
            <p>这是一个概念性问题。调试并行程序通常被认为比调试串行程序<b>困难得多</b>。原因包括：</p>
            <ul>
                <li><b>竞争条件 (Race Conditions)</b>: 多个线程访问共享资源的结果取决于它们执行的精确时间顺序。</li>
                <li><b>死锁 (Deadlocks)</b>: 两个或多个线程相互等待对方释放资源。</li>
                <li><b>不确定性</b>: 并行程序的执行路径可能每次都不同，使得错误难以复现。这些难以捉摸的 bug 有时被称为“海森堡bug”（Heisenbugs）。</li>
            </ul>
            <p>由于这些复杂性，调试并行程序需要专门的工具和技术。因此，该陈述是<b>错误</b>的。</p>
        </div>

        <div class="problem">
            <h2>题目 1-6</h2>
            <div class="meta-info">
                <p><b>题目:</b> 回溯算法的时间复杂度分析之所以非常困难，是因为解空间的大小可能会变化。</p>
                <p><b>您的答案:</b> <span class="answer-correct">错误 (FALSE)</span></p>
                <p><b>评判结果:</b> <span class="judge-correct">正确 (ACCEPTED)</span></p>
                <p><b>正确答案:</b> <span class="answer-correct">错误 (FALSE)</span></p>
            </div>
            <h3>解析:</h3>
            <p>虽然解空间（或搜索空间）的大小变化是分析复杂性的一个因素，但这并不是<b>根本</b>或<b>最主要</b>的困难所在。对于大多数算法，输入的变化都会导致计算量的变化。</p>
            <p>回溯算法分析的真正困难在于<b>量化剪枝（pruning）的效果</b>。回溯算法通过在搜索过程中剪掉那些不可能产生解的子树来提高效率。分析的难点在于精确地估算有多少搜索空间被剪掉了，因为剪枝的效果高度依赖于具体问题和输入数据。因此，仅仅说“解空间大小会变”是对问题核心难度的不精确描述。</p>
            <p>因此，该陈述被认为是<b>错误</b>的。</p>
        </div>

        <div class="problem">
            <h2>题目 1-7</h2>
            <div class="meta-info">
                <p><b>题目:</b> 一个非满二叉树（a binary tree that is not full）不可能对应于一个最优前缀码。</p>
                <p><b>您的答案:</b> <span class="answer-correct">正确 (TRUE)</span></p>
                <p><b>评判结果:</b> <span class="judge-correct">正确 (ACCEPTED)</span></p>
                <p><b>正确答案:</b> <span class="answer-correct">正确 (TRUE)</span></p>
            </div>
            <h3>解析:</h3>
            <p>最优前缀码通常由<b>霍夫曼树（Huffman Tree）</b>生成。</p>
            <ul>
                <li><b>满二叉树</b>是指每个节点要么是叶子节点（度为0），要么有两个子节点（度为2）。</li>
                <li>霍夫曼编码的构造过程是每次选择两个频率最低的节点合并成一个新的父节点。这个过程确保了所有非叶子节点（内部节点）都有两个子节点。</li>
                <li>因此，一个标准的霍夫曼树总是满二叉树。如果一个树不是满二叉树，意味着它至少有一个内部节点只有一个孩子。在这种情况下，我们可以通过移除这个单孩子的内部节点，并将其孩子直接连接到其祖父节点上，从而缩短路径，得到一个更优或等优的编码。这与“最优”的假设相矛盾。</li>
            </ul>
            <p>因此，该陈述是<b>正确</b>的。</p>
        </div>

        <div class="problem">
            <h2>题目 1-8</h2>
            <div class="meta-info">
                <p><b>题目:</b> NP-hard 问题和 NP-complete 问题都是 NP 问题的子集。</p>
                <p><b>您的答案:</b> <span class="answer-correct">错误 (FALSE)</span></p>
                <p><b>评判结果:</b> <span class="judge-correct">正确 (ACCEPTED)</span></p>
                <p><b>正确答案:</b> <span class="answer-correct">错误 (FALSE)</span></p>
            </div>
            <h3>解析:</h3>
            <p>这个陈述混淆了计算复杂性类的定义：</p>
            <ul>
                <li><b>NP</b>: 可以在多项式时间内<b>验证</b>一个解是否正确的决策问题集合。</li>
                <li><b>NP-complete (NPC)</b>: 既属于 NP 又属于 NP-hard 的问题。所以，<b>NPC 问题是 NP 问题的子集</b>。</li>
                <li><b>NP-hard</b>: 任何 NP 问题都可以在多项式时间内归约到它的问题。一个 NP-hard 问题<b>不一定</b>属于 NP。例如，停机问题（Halting Problem）是 NP-hard 的，但它甚至不是一个可判定的问题，因此不属于 NP。</li>
            </ul>
            <p>因为陈述中说 <b>NP-hard 问题</b>也是 NP 的子集，这是错误的。所以整个陈述是<b>错误</b>的。</p>
        </div>

        <div class="problem">
            <h2>题目 1-9</h2>
            <div class="meta-info">
                <p><b>题目:</b> 在整个文档集中词频（term frequency）很高的一个词必定是停用词（stop word）。</p>
                <p><b>您的答案:</b> <span class="answer-correct">错误 (FALSE)</span></p>
                <p><b>评判结果:</b> <span class="judge-correct">正确 (ACCEPTED)</span></p>
                <p><b>正确答案:</b> <span class="answer-correct">错误 (FALSE)</span></p>
            </div>
            <h3>解析:</h3>
            <ul>
                <li><b>停用词</b>通常指那些在文本中频繁出现但信息量低的词，如 "the", "is", "a"。它们通常具有很高的<b>文档频率（Document Frequency）</b>，即在很多文档中都出现。</li>
                <li><b>词频（Term Frequency）</b>指的是一个词在单个文档或整个文档集中的出现次数。</li>
                <li>一个词在整个文档集中总词频高，并不意味着它就是停用词。例如，在一个关于“机器学习”的论文集中，“模型”、“数据”、“算法”这些词的词频会非常高，但它们是关键的领域术语，而不是需要被过滤掉的停用词。</li>
                <li>陈述中的“必定”（must be）过于绝对，很容易找到反例。因此，该陈述是<b>错误</b>的。</li>
            </ul>
        </div>

        <div class="problem">
            <h2>题目 1-10</h2>
            <div class="meta-info">
                <p><b>题目:</b> 当向一个非空的 2-3 树中插入三个键时，如果插入第一个键时树的高度增加了，那么我们可以确定在插入后两个键时，树的高度将<b>不会</b>增加。</p>
                <p><b>您的答案:</b> <span class="answer-correct">正确 (TRUE)</span></p>
                <p><b>评判结果:</b> <span class="judge-correct">正确 (ACCEPTED)</span></p>
                <p><b>正确答案:</b> <span class="answer-correct">正确 (TRUE)</span></p>
            </div>
            <h3>解析:</h3>
            <p>2-3 树增加高度的唯一情况是<b>根节点发生分裂</b>。</p>
            <ol>
                <li><b>第一次插入增加高度</b>: 这意味着插入路径上的所有节点（从叶节点到根节点）都已经是 3-节点（即有两个键，三个子节点）。当插入第一个键时，会引起一连串的分裂，一直传递到根节点，导致原根节点分裂，从而树高增加 1。</li>
                <li><b>分裂后的新根</b>: 当原来的 3-节点根分裂时，它中间的键会成为新的根节点，这个新的根节点是一个 <b>2-节点</b>（只有一个键，两个子节点）。</li>
                <li><b>后续两次插入</b>: 现在，新的根是一个 2-节点。要让树再次增高，这个新的根节点必须再次分裂。但是，它需要先从 2-节点变成 3-节点（吸收一次从下面传递上来的分裂），然后再吸收一次分裂才会导致自身分裂。仅仅两次后续插入，最多只能让新根变成 3-节点，或者在子树中引起分裂，但不足以让这个新的 2-节点根再次分裂。</li>
            </ol>
            <p>因此，如果第一次插入就增加了高度，那么接下来两次插入是不足以让树的高度再次增加的。该陈述是<b>正确</b>的。</p>
        </div>

        <div class="problem">
            <h2>题目 1-11</h2>
            <div class="meta-info">
                <p><b>题目:</b> 假设使用置换选择法（replacement selection）为一个包含 N 个数的集合生成更长的顺串（runs），其中优先队列的大小为 M。那么最长顺串的可能最大长度是 N。</p>
                <p><b>您的答案:</b> <span class="answer-correct">正确 (TRUE)</span></p>
                <p><b>评判结果:</b> <span class="judge-correct">正确 (ACCEPTED)</span></p>
                <p><b>正确答案:</b> <span class="answer-correct">正确 (TRUE)</span></p>
            </div>
            <h3>解析:</h3>
            <p>置换选择法是外排序中用于生成初始顺串的算法。它使用一个大小为 M 的最小优先队列（堆）。</p>
            <p>算法的最好情况发生在输入数据<b>已经完全有序</b>时。</p>
            <p>如果输入的 N 个数已经是升序排列的，那么每次从堆中取出最小值并写入顺串后，从输入文件中读入的下一个数总是比刚写出的数要大。因此，这个新数总可以被加入到当前的堆中，而不会被放入为下一个顺串准备的区域。这个过程会一直持续，直到所有 N 个数都被处理完毕，形成一个长度为 N 的单一顺串。</p>
            <p>因此，最长顺串的可能最大长度确实是 N。该陈述是<b>正确</b>的。</p>
        </div>

        <div class="problem">
            <h2>题目 1-12</h2>
            <div class="meta-info">
                <p><b>题目:</b> 对于一个优化问题，给定一个邻域结构，如果它的局部最优解同时也是全局最优解，那么通过一步局部改进就可以达到一个最优解。</p>
                <p><b>您的答案:</b> <span class="answer-correct">错误 (FALSE)</span></p>
                <p><b>评判结果:</b> <span class="judge-correct">正确 (ACCEPTED)</span></p>
                <p><b>正确答案:</b> <span class="answer-correct">错误 (FALSE)</span></p>
            </div>
            <h3>解析:</h3>
            <p>陈述的前半部分“如果它的局部最优解同时也是全局最优解”描述了问题的一个良好性质（例如，线性规划问题就具有这个性质）。这意味着局部搜索算法不会陷入非全局最优的局部极值点。</p>
            <p>然而，陈述的后半部分“通过<b>一步</b>局部改进就可以达到一个最优解”是错误的。局部搜索算法从一个初始解开始，<b>迭代地</b>移动到邻域中更好的解。这个过程可能需要很多步才能最终到达那个既是局部最优又是全局最优的解。一步局部改进仅仅是从当前解移动到一个比它更好的相邻解，这个相邻解几乎不可能是全局最优解（除非运气极好，初始解的邻域里恰好有全局最优解）。</p>
            <p>例如，在一个简单的单调递增的路径 5 -> 10 -> 15 -> 20（全局最优）上，如果从 5 开始，一步只能到达 10，需要多步才能到达 20。因此，该陈述是<b>错误</b>的。</p>
        </div>
        
        <div class="problem">
            <h2>题目 1-13</h2>
            <div class="meta-info">
                <p><b>题目:</b> 回顾活动选择问题... 贪心策略中，选择长度最短的活动（SF）并非总是最优的。但是，我们断言 SF 至少能选择 $|OPT|/2$ 个活动，其中 $|OPT|$ 是最优解中的活动数量。请检查以下证明是否正确：[证明内容]</p>
                <p><b>您的答案:</b> <span class="answer-incorrect">错误 (FALSE)</span></p>
                <p><b>评判结果:</b> <span class="judge-incorrect">错误 (WRONG_ANSWER)</span></p>
                <p><b>正确答案:</b> <span class="answer-correct">正确 (TRUE)</span></p>
            </div>
            <h3>解析:</h3>
            <p>这个问题是要求判断给出的<b>证明过程</b>是否正确。这个证明本身是在论证“最短活动优先”的贪心策略是活动选择问题的一个 2-近似算法。</p>
            <p>让我们来分析这个证明的核心论点：<b>“SF 接受的每个活动最多只与 OPT 中的两个活动冲突，因此最多收到两美元”</b>。这个论点是正确的，可以证明如下：</p>
            <ol>
                <li>令 $a_j$ 是 SF 算法选出的一个活动，其区间为 $[s_j, f_j]$。</li>
                <li>令 $a_i$ 是最优解 OPT 中的一个活动，且它与 $a_j$ 冲突（即它们的区间重叠）。</li>
                <li>当 SF 算法选择 $a_j$ 时，$a_i$ 也必然是当时可供选择的活动之一。因为 SF 选择了 $a_j$ 而不是 $a_i$，根据“最短优先”的规则，必然有 $\text{length}(a_j) \le \text{length}(a_i)$。</li>
                <li>现在，考虑所有与 $a_j$ 冲突的 OPT 中的活动。这些活动在 OPT 中是互不重叠的。如果一个活动 $a_i$ 与 $a_j$ 重叠，并且它的长度不小于 $a_j$，那么它必须包含 $a_j$ 的开始时间点 $s_j$ 或结束时间点 $f_j$。（如果它既不包含 $s_j$ 也不包含 $f_j$，那它就会被完全包含在 $a_j$ 内部，从而比 $a_j$ 更短，这与第3点矛盾）。</li>
                <li>由于 OPT 中的活动是互不重叠的，所以最多只有一个活动可以包含 $s_j$，最多只有一个活动可以包含 $f_j$。</li>
                <li>因此，最多只有两个 OPT 中的活动能与 $a_j$ 冲突。</li>
            </ol>
            <p>这个核心论点成立，那么整个“充电法”的证明逻辑也就成立了：$|OPT|$ 份“钱”被分配给 SF 的活动，每个 SF 活动最多收到 2 份，因此 $|S| \ge |OPT|/2$。</p>
            <p>所以，这个证明是<b>正确</b>的。</p>
        </div>

    </div>

</body>
</html>